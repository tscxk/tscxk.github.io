<!doctype html>
<html
  lang="zh-cn" 
  data-theme-mode="auto"
  >
  <head><meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/><title>
  Redis | tscxk
</title>
<meta
  name="description"
  content="Redis面试知识"
/><script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"base\":\"https://tscxk.github.io/\",\"clipboard\":{\"copyright\":{\"count\":50,\"enable\":false,\"license_type\":\"by-nc-sa\"},\"fail\":{\"en\":\"Copy failed (ﾟ⊿ﾟ)ﾂ\",\"ja\":\"コピー失敗 (ﾟ⊿ﾟ)ﾂ\",\"pt-br\":\"Falha ao copiar (ﾟ⊿ﾟ)ﾂ\",\"zh-cn\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"zh-tw\":\"複製失敗 (ﾟ⊿ﾟ)ﾂ\"},\"success\":{\"en\":\"Copy successfully (*^▽^*)\",\"ja\":\"コピー成功 (*^▽^*)\",\"pt-br\":\"Copiado com sucesso (*^▽^*)\",\"zh-cn\":\"复制成功 (*^▽^*)\",\"zh-tw\":\"複製成功 (*^▽^*)\"}},\"code_block\":{\"expand\":true},\"i18n_languages\":[{\"Lang\":\"en\",\"LanguageName\":\"English\",\"LanguageCode\":\"\",\"Title\":\"\",\"LanguageDirection\":\"\",\"Weight\":1,\"Disabled\":false},{\"Lang\":\"zh-cn\",\"LanguageName\":\"简体中文\",\"LanguageCode\":\"\",\"Title\":\"\",\"LanguageDirection\":\"\",\"Weight\":1,\"Disabled\":false},{\"Lang\":\"zh-tw\",\"LanguageName\":\"繁體中文\",\"LanguageCode\":\"\",\"Title\":\"\",\"LanguageDirection\":\"\",\"Weight\":1,\"Disabled\":false}],\"icon_font\":\"4552607_4k4bc36ef96\",\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":{\"en\":\"This article was last updated on {time}. Please note that the content may no longer be applicable.\",\"ja\":\"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。\",\"pt-br\":\"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.\",\"zh-cn\":\"本文最后更新于 {time}，请注意文中内容可能已不适用。\",\"zh-tw\":\"本文最後更新於 {time}，請注意文中內容可能已不適用。\"}}}");
  
</script>
<link
    rel="preload"
    as="style"
    crossorigin
    href="https://fontsapi.zeoseven.com/292/main/result.css"
    onload="this.rel='stylesheet'"
  /><link
    rel="preload"
    href="//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2"
    as="font"
    type="font/woff2"
    crossorigin="anonymous"
  /><link rel="stylesheet" href="/css/loader.min.14df05c02c63459533ffcbb5e07f8ba38b8a4eed13a1e5c3b19d3045491c4e2a.css" />
<meta property="og:type" content="website" />
  <meta property="og:title" content="Redis | tscxk" />
  <meta
    property="og:description"
    content="Redis面试知识"
  />
  <meta property="og:url" content="https://tscxk.github.io/post/interview/redis/" />
  <meta
    property="og:site_name"
    content="My New Hugo Site"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="tscxk" />
  <meta property="article:published_time" content="2025-09-05T09:59:02&#43;08:00" />
  <meta property="article:modified_time" content="2025-09-07T23:17:12&#43;08:00" /><meta property="article:tag" content="redis" /><meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
<link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/main.min.17c905cd4d0df4b63a6a2d1aa20d344aa9e2450f1441cd34a78159e8a421f814.css" />
<link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    integrity="sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei&#43;Zx/1oA/0l8ysE" crossorigin="anonymous"onload="this.onload=null;this.rel='stylesheet'"
  /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.22/dist/katex.min.css"
    integrity="sha384-5TcZemv2l/9On385z///&#43;d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous"onload="this.onload=null;this.rel='stylesheet'"
  /><script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script><link
    rel="stylesheet"
    href="https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css"
    integrity="sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa" crossorigin="anonymous"/></head>
  <body><div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi rotate"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
          M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg></div><div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script><div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>
<div id="lang-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
本文章没有找到对应的语言版本
</div>
<div id="heatmap-tooltip"></div><div id="container">
      <div id="wrap"><div id="header-nav">
  <nav id="main-nav"><span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>&#xe62b;</div>
        <a class="main-nav-link" href="/">首页</a>
      </span><span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>&#xe62b;</div>
        <a class="main-nav-link" href="/archives">归档</a>
      </span><span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>&#xe62b;</div>
        <a class="main-nav-link" href="/about">关于</a>
      </span><span class="main-nav-link-wrap">
        <div class='main-nav-icon icon rotate'>&#xe62b;</div>
        <a class="main-nav-link" href="/friend">友链</a>
      </span><a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav"></nav><nav id="i18n-nav">
      <div class="custom-dropdown">
        <div class="select-selected" id="select-selected">
          <span id="nav-language-btn" class="nav-icon" style="padding: 0 20px 0 0"></span>
          <span id="selected-lang">简体中文</span>
        </div>
        <ul class="select-items" id="select-items"><li data-value="en"  >English</li><li data-value="zh-cn" class="selected" >简体中文</li><li data-value="zh-tw"  >繁體中文</li></ul>
      </div>
      <script>
        var selectSelected = document.getElementById("select-selected");
        var selectedLang = document.getElementById("selected-lang");
        var selectItems = document.getElementById("select-items");
        var selectOptions = selectItems.querySelectorAll("li");

        selectSelected.addEventListener("click", () => {
          selectItems.classList.toggle("show");
        });

        selectOptions.forEach((item) => {
          item.addEventListener("click", () => {
            const langMap = {};selectedLang.textContent = item.textContent;
            selectItems.classList.remove("show");
            selectOptions.forEach((option) => {
              option.classList.remove("selected");
            });
            item.classList.add("selected");
            if (item.dataset.value === 'zh-cn') {
              return;
            }
            if (!langMap[item.dataset.value]) {
              _$("#lang-tooltip").style.opacity = "1";
              setTimeout(() => {
                _$("#lang-tooltip").style.opacity = "0";
              }, 1000);
              return;
            }
            window.location = langMap[item.dataset.value];
          });
        });

        document.addEventListener("click", (event) => {
          if (!event.target.closest(".custom-dropdown")) {
            selectItems.classList.remove("show");
          }
        });
      </script>
    </nav></div>
<header id="header"><picture></picture><img  fetchpriority="high" src="/images/banner.webp" alt="Redis"><div id="header-outer">
    <div id="header-title"><span id="logo">
            <h1 data-aos="slide-up">Redis</h1>
          </span><h2 id="subtitle-wrap" data-aos="slide-down"></h2></div>
  </div>
</header><div id="content"
          class="sidebar-left"
            ><aside id="sidebar"><div class="sidebar-wrapper-container sticky"><div class="sidebar-wrapper">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    ><div class="sidebar-toc-sidebar"><h3 class="toc-title">文章目录</h3>
<div class="sidebar-toc-wrapper toc-div-class">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#redis基础">Redis基础</a>
      <ul>
        <li><a href="#1-使用缓存的优缺点">1. 使用缓存的优缺点</a></li>
        <li><a href="#2-redis的数据类型和使用场景">2. Redis的数据类型和使用场景</a></li>
        <li><a href="#3-redis的过期策略">3. Redis的过期策略</a></li>
        <li><a href="#4-redis的内存淘汰策略">4. Redis的内存淘汰策略</a></li>
        <li><a href="#4-redis的事务机制">4. Redis的事务机制</a></li>
        <li><a href="#5-redis为什么这么快">5. Redis为什么这么快？</a></li>
        <li><a href="#6-redis持久化">6. Redis持久化</a></li>
        <li><a href="#7-aof持久化导致主进程阻塞">7. AOF持久化导致主进程阻塞</a></li>
        <li><a href="#8-redis集群高可用常见方式">8. Redis集群高可用常见方式</a></li>
        <li><a href="#9-缓存一致性">9. 缓存一致性</a></li>
        <li><a href="#10-缓存穿透缓存击穿和缓存雪崩">10. 缓存穿透、缓存击穿和缓存雪崩</a></li>
        <li><a href="#11-一致性hash算法todo">11. 一致性hash算法（TODO）</a></li>
        <li><a href="#12-数据分片">12. 数据分片</a></li>
        <li><a href="#13-怎么处理热key">13. 怎么处理热key</a></li>
        <li><a href="#14-分布式锁todo">14. 分布式锁(TODO)</a></li>
      </ul>
    </li>
    <li><a href="#综合">综合</a>
      <ul>
        <li><a href="#1-手写一个lrutodo">1. 手写一个LRU（TODO）</a></li>
        <li><a href="#2-寻找大量key">2. 寻找大量key</a></li>
        <li><a href="#3-redis如何做异步消息队列-需要注意什么">3. Redis如何做异步消息队列 需要注意什么？</a></li>
        <li><a href="#4-rdb和copy-on-write">4. RDB和Copy On Write</a></li>
        <li><a href="#5-redis阻塞问题怎么排查和解决">5. Redis阻塞问题怎么排查和解决</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div></div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="tscxk"
    class="lazyload"
  />
  <div class="sidebar-author-name">tscxk</div>
  <div class="sidebar-description">叽里咕噜...</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div><div class="sidebar-state-number">8</div>
  </div>
  <a class="sidebar-state-category" href="/categories/" aria-label="sidebar-state-category-link">
    <div>分类</div>
    <div class="sidebar-state-number">
      3
    </div>
  </a>
  <a class="sidebar-state-tag" href="/tags/" aria-label="sidebar-state-tag-link">
    <div>标签</div>
    <div class="sidebar-state-number">9</div>
  </a>
</div>
<div class="sidebar-social"></div>
<div class="sidebar-menu"><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">首页</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">归档</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">关于</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">友链</div>
    </div></div>
</div><div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div></div>
  </div><div class="sidebar-widget"></div></div></aside>
<section id="main"><article
  class="h-entry article"
  itemprop="blogPost"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta"><div class="article-date">
  <span
    class="article-date-link icon-calendar"
    data-aos="zoom-in"
  >
    <time datetime="2025-09-05 09:59:02 &#43;0800 CST" itemprop="datePublished"
      >2025-09-05</time
    >
    <time style="display: none;" id="post-update-time"
      >2025-09-07</time
    >
  </span><span
      class="article-date-link icon-calendar-plus"
      data-aos="zoom-in"
    >
      <time datetime="2025-09-07 23:17:12.4391263 &#43;0800 CST" itemprop="dateModified"
        >2025-09-07</time
      >
    </span></div>
<div class="article-category"><a
      class="article-category-link"
      href="/categories/%e9%9d%a2%e8%af%95"
      data-aos="zoom-in"
      >面试</a
    ></div>
</div><div class="hr-line"></div><div class="e-content article-entry" itemprop="articleBody"><h2 id="redis基础">
<a class="header-anchor" href="#redis%e5%9f%ba%e7%a1%80"></a>
Redis基础
</h2><blockquote>
<p>Redis是用C语言开发的</p></blockquote>
<h3 id="1-使用缓存的优缺点">
<a class="header-anchor" href="#1-%e4%bd%bf%e7%94%a8%e7%bc%93%e5%ad%98%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9"></a>
1. 使用缓存的优缺点
</h3><h4 id="优点">
<a class="header-anchor" href="#%e4%bc%98%e7%82%b9"></a>
优点
</h4><ul>
<li>
<p>高性能（最根本的问题）</p>
<p>对于能够容忍短时间内不一致的数据，使用缓存能够大大加快查询时间并降低数据库压力。因为缓存通常基于内存，性能相较于使用磁盘的数据库要强上许多数量级。</p>
</li>
<li>
<p>高并发</p>
<p>缓存基于内存，它所能提供的qps要大大高于数据库</p>
</li>
</ul>
<h4 id="缺点">
<a class="header-anchor" href="#%e7%bc%ba%e7%82%b9"></a>
缺点
</h4><ul>
<li>缓存和数据库的不一致性</li>
<li>缓存穿透、击穿、雪崩问题</li>
</ul>
<h3 id="2-redis的数据类型和使用场景">
<a class="header-anchor" href="#2-redis%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%92%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af"></a>
2. Redis的数据类型和使用场景
</h3><h4 id="string">
<a class="header-anchor" href="#string"></a>
String
</h4><p>最基础的数据类型，可以存储任何数据，包括文字、数字、二进制数据、序列化后的java对象</p>
<ul>
<li>
<p>常用命令：get、set、incr、decr</p>
</li>
<li>
<p>使用场景：</p>
<ul>
<li>
<p>简单对象缓存：如用户信息等，序列化成JSON后存入</p>
</li>
<li>
<p>计数器：例如限流、</p>
</li>
<li>
<p>分布式锁：使用<code>SET key value NX EX seconds</code> 实现简单的分布式锁</p>
</li>
</ul>
</li>
</ul>
<h4 id="hash">
<a class="header-anchor" href="#hash"></a>
Hash
</h4><p>类似于Java中的Map，适合存储对象</p>
<ul>
<li>常用命令：hset、hget、hgetall、hmset、hincrby</li>
<li>使用场景：
<ul>
<li>存储完整对象信息，需要频繁进行若干字段的变更：例如购物车</li>
</ul>
</li>
</ul>
<h4 id="list">
<a class="header-anchor" href="#list"></a>
List
</h4><p>简单的字符串列表，按照插入顺序排序，底层实现是双向链表</p>
<ul>
<li>常用命令：lpush、rpush、lpop、rpop、lrange</li>
<li>使用场景：
<ul>
<li>消息队列：基于redis实现简单的消息队列</li>
<li>最新列表：某个用户最近的朋友圈、最近的操作记录等不需要去重的场景</li>
</ul>
</li>
</ul>
<h4 id="set">
<a class="header-anchor" href="#set"></a>
Set
</h4><p>无序的、元素唯一的字符串集合。支持交集、并集、差集等操作</p>
<ul>
<li>常用命令：sadd、smembers、sismember、sinter、sunion、sdiff</li>
<li>使用场景：
<ul>
<li>求交集：共同好友、兴趣爱好</li>
<li>求差集：推荐好友</li>
<li>去重场景：抽奖用户添加</li>
</ul>
</li>
</ul>
<h4 id="zset">
<a class="header-anchor" href="#zset"></a>
ZSet
</h4><p>最特色的数据类型，相较于set，每个元素都关联一个权重（分数），Redis可以根据这个权重对所有数据进行排序</p>
<ul>
<li>常用命令：zadd、zrange、zrevrange、zrank、zrevrank</li>
<li>使用场景：
<ul>
<li>带有权重的排行榜：例如积分排行榜、充值排行榜</li>
<li>延迟队列：使用时间戳作为权重，消费者使用<code>ZRANGEBYSCORE</code> 查询到期的任务来处理</li>
<li>范围查询：例如处理价格范围、时间范围的数据</li>
</ul>
</li>
</ul>
<h4 id="bitmap">
<a class="header-anchor" href="#bitmap"></a>
Bitmap
</h4><ul>
<li>使用场景：具备状态的二值统计，例如用户签到记录、活跃用户统计</li>
</ul>
<h4 id="hyperloglog">
<a class="header-anchor" href="#hyperloglog"></a>
Hyperloglog
</h4><ul>
<li>使用场景：统计网站的UB，统计搜索关键字的不重复数量</li>
</ul>
<h4 id="bloom">
<a class="header-anchor" href="#bloom"></a>
Bloom
</h4><p>Redis 布隆过滤器（Bloom Filter）是一个非常有用的概率型数据结构，用于高效地判断一个元素<strong>是否可能存在于集合中</strong>或<strong>肯定不存在于集合中</strong>。</p>
<p><strong>存在一定的误判率</strong></p>
<ul>
<li>使用场景：
<ul>
<li>缓存穿透防护（最经典场景）：例如判断id是否在集合里面</li>
<li>url检测：判断当期url信息是否爬取过</li>
</ul>
</li>
</ul>
<h4 id="geo">
<a class="header-anchor" href="#geo"></a>
geo
</h4><p>专门用于存储和操作地理位置信息（经纬度）。</p>
<ul>
<li>使用场景：计算两地之间的距离、查找某个地点指定半径内的所有地点（如“附近的酒店”）。</li>
</ul>
<h3 id="3-redis的过期策略">
<a class="header-anchor" href="#3-redis%e7%9a%84%e8%bf%87%e6%9c%9f%e7%ad%96%e7%95%a5"></a>
3. Redis的过期策略
</h3><p>由于可能存在大量数据设置了过期时间，redis不可能随时都遍历全部数据并删除那些过期数据，因此Redis采用两种主要策略来处理过期键的删除：</p>
<ol>
<li>
<p>定期删除</p>
<p>redis每隔一段时间（默认每秒10次）随机抽取一定数量的键，然后检查这些键是否过期，如果过期则删除。如果发现过期键比例较高，会增加抽样数量。</p>
<p>优点：主动清理</p>
<p>缺点：占用cpu、清理不彻底</p>
</li>
<li>
<p>惰性删除</p>
<p>当用户尝试访问一个键时，redis会先检查该键是否设置了过期时间以及是否过期，如果已经过期，那么redis会立即删除该键并返回控制或者错误。</p>
<p>优点：cpu占用较低</p>
<p>缺点：不访问的键可能永远都清理不到</p>
</li>
</ol>
<p>尽管redis使用了两种策略来处理过期数据，然而仍然会存在部分数据访问不能被及时扫描造成内存占用。因此redis还提供了<strong>内存淘汰机制作为内存不足时提供的兜底选择</strong>。</p>
<h3 id="4-redis的内存淘汰策略">
<a class="header-anchor" href="#4-redis%e7%9a%84%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5"></a>
4. Redis的内存淘汰策略
</h3><ol>
<li>
<p>noevicition（不淘汰）</p>
<ul>
<li>
<p>行为：当内存不足时，新写入操作会返回错误，读操作正常继续。</p>
</li>
<li>
<p>场景：适用于数据绝对不允许丢失的场景，如关键配置存储</p>
</li>
</ul>
</li>
<li>
<p>allkeys-lru</p>
<ul>
<li>行为：从所有键中按照最近最少使用的原则进行淘汰</li>
<li>场景：常用策略，适合大多数缓存场景</li>
</ul>
</li>
<li>
<p>volatile-lru</p>
<ul>
<li>行为：从设置了过期时间的键中按照最近最少使用的原则进行淘汰</li>
<li>场景：需要区分持久数据和临时数据的场景</li>
</ul>
</li>
<li>
<p>allkeys-random</p>
<ul>
<li>行为：从所有键中按照随机的选择进行淘汰</li>
<li>场景：所有键都被平等访问，没有明显访问模式</li>
</ul>
</li>
<li>
<p>volatile-random</p>
<ul>
<li>行为：从设置了过期时间的键中按照随机的选择进行淘汰</li>
<li>场景：临时数据之间没有明显访问模式差异</li>
</ul>
</li>
<li>
<p>allkeys-lfu</p>
<ul>
<li>行为：从<strong>所有键</strong>中淘汰<strong>最不经常使用</strong>的</li>
<li>场景：基于访问频率而非最近访问时间</li>
</ul>
</li>
<li>
<p>volatile-lfu</p>
<ul>
<li>行为：从<strong>设置了过期时间的键</strong>中淘汰<strong>最不经常使用</strong>的</li>
<li>场景：临时数据中存在访问频率差异的场景</li>
</ul>
</li>
<li>
<p>volatile-ttl</p>
<ul>
<li>行为：从<strong>设置了过期时间的键</strong>中淘汰<strong>剩余生存时间最短</strong>的</li>
<li>场景：基于过期时间而非访问模式</li>
</ul>
</li>
</ol>
<p>其中:</p>
<ul>
<li>lru（默认）: 根据访问时间，能够有效保留热门数据</li>
<li>lfu：根据访问频次</li>
<li>random：简单公平</li>
<li>ttl：优先淘汰快过期的</li>
</ul>
<h3 id="4-redis的事务机制">
<a class="header-anchor" href="#4-redis%e7%9a%84%e4%ba%8b%e5%8a%a1%e6%9c%ba%e5%88%b6"></a>
4. Redis的事务机制
</h3><p>Redis 的事务机制与关系型数据库（如 MySQL）的事务有显著不同。它提供了一种将多个命令打包、按顺序执行的方式，但不支持回滚操作。</p>
<p>同时在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。</p>
<p>redis事务特性：</p>
<ol>
<li>
<p>原子性：</p>
<p>事务中的所有命令要么全部执行（不论成功失败），要么全部不执行。如果某个命令失败，后续命令仍然会继续执行。</p>
</li>
<li>
<p>隔离性：</p>
<p>Redis 是单线程的，事务中的所有命令会按顺序执行，不会被其他客户端命令打断</p>
</li>
</ol>
<p>Redis通过MULTI、EXEC、DISCARD等命令来实现事务机制。其中还提供了Watch命令作为乐观锁机制。</p>
<h4 id="redis为什么不支持回滚">
<a class="header-anchor" href="#redis%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%94%af%e6%8c%81%e5%9b%9e%e6%bb%9a"></a>
redis为什么不支持回滚？
</h4><p>这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以<strong>保持简单、快速的特性</strong>。</p>
<h3 id="5-redis为什么这么快">
<a class="header-anchor" href="#5-redis%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab"></a>
5. Redis为什么这么快？
</h3><ol>
<li>
<p>基于内存</p>
<p>Redis完全基于内存操作，避免了与磁盘之间的交互，大大降低响应时间</p>
</li>
<li>
<p>单线程</p>
<p>避免了频繁的上下文切换。就目前来看，Redis瓶颈基本都在网络侧而不是CPU侧</p>
</li>
<li>
<p>非阻塞的IO多路复用机制</p>
<p>Redis 采用网络 IO 多路复用技术，来保证在多连接的时候系统的高吞吐量。 多路-指的是多个 socket网络连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll 是最新的、也是目前最好的多路复用技术。 采用多路 I/O 复用技术,可以让单个线程高效处理多个连接请求（尽量减少网络 IO 的时间消耗）。并且 Redis 在内存中操作数据的速度非常快（因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈）。主要以上两点造就了 Redis 具有很高的吞吐量。 采用多路 I/O复用技术可以让单个线程高效的处理多个连接请求。</p>
</li>
<li>
<p>高效的数据结构</p>
<ul>
<li>
<p>SDS（简单动态字符串）：sds记录了len（使用长度）、free（剩余空间）、buf（存储的实际内容）</p>
<blockquote>
<p>尽管Redis是用C语言开发的，但是redis的字符串并没有直接使用C语言的字符串，而是使用称为SDS的结构体来保存字符串。其根本原因是因为C语言原生字符串无法满足redis作为一个高性能、高可靠性的需求。</p>
<p>相较于C语言字符串有以下优化：</p>
<ol>
<li>保存了字符串长度：C语言字符串每次获取长度信息需要遍历整个字符串，而SDS保存了len信息</li>
<li>二进制安全：C语言字符串读取到结束符就结束了，这意味着它无法保存结束符，也无法存储任意二进制数据，而SDS是根据len长度来判断字符串结束，因此SDS可以存储任意二进制数据。</li>
<li>拒绝缓冲区溢出：SDS的所有修改都会先检查剩余空间，如果空间不足会自动扩容，从根源上杜绝了缓冲区溢出的可能性</li>
<li>减少内存重新分配次数：C语言每次变更字符串长度都会进行内存的重分配，严重影响性能，SDS则提供两种优化策略：
<ul>
<li>空间预分配：当 SDS 需要扩容时，它不仅会分配所需的空间，还会额外分配一定的<strong>冗余空间（<code>free</code>）</strong>。下次再追加数据时，如果冗余空间足够，就直接使用，避免了频繁分配。</li>
<li>惰性空间释放：当缩短 SDS 时，它不会立即释放多余的内存，而是通过增加 <code>free</code> 的值将其保留下来，以备后续增长操作时使用。真正的释放有专门的 API 在需要时执行。</li>
</ul>
</li>
</ol>
<p>尽管SDS可能需要更高的内存占用和额外的性能消耗，但是却能够换来巨大的性能提升。</p>
<ul>
<li>额外的内存开销</li>
</ul></blockquote>
</li>
<li>
<p>哈希表</p>
</li>
<li>
<p>双向链表</p>
</li>
<li>
<p>哈希表：键值对，能够在O(1)的时间内获取对应的键值</p>
</li>
<li>
<p>双向链表：带有前后指针的链表，方便从两头进行添加/删除操作</p>
</li>
<li>
<p><strong>压缩链表（现在已经被listpack取代）</strong>：</p>
<p>压缩列表是一块连续的内存空间，它不像链表那样需要额外的指针开销，而是将所有数据（条目/Entry）一个紧挨着一个地存储。它本质上是 “基于字节数组实现的双向链表”。其核心目的是提供最高效的内存效率</p>
<p>优点：</p>
<ul>
<li><strong>极致的内存效率</strong>：这是它最大的优点。通过变长编码和紧凑排列，大大减少了内存碎片和指针 overhead。</li>
<li><strong>缓存友好</strong>：数据存储在连续内存中，容易被CPU缓存命中，访问速度快。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>查找效率低</strong>：<strong>查询时间复杂度是 O(n)</strong>。尽管是数组，然而并没有记录每个entry的起始位置，因此必须遍历每个 <code>Entry</code> 才能找到目标元素。不适合存储大量元素。</li>
<li>连锁更新风险：这个了解即可</li>
</ul>
</li>
<li>
<p>跳表：<strong>多层有序链表</strong>，每一层都是下一层的快速通道</p>
<ul>
<li>时间复杂度：
<ul>
<li>平均：O(log n)</li>
<li>最坏：O(n)</li>
</ul>
</li>
<li>空间负责度： O(n) （但比平衡树更加节省资源）</li>
</ul>
<blockquote>
<p>为什么 Redis的ZSet选择跳跃表而不是二分查找/平衡树?</p>
<ol>
<li>
<p>动态数据支持：</p>
<p>ZSET需要频繁插入、删除，跳表的插入、删除效率远高于基于数组的二分查找的效率，同时比平衡树调整也更加简单</p>
</li>
<li>
<p>实现简单：</p>
<p>相较于平衡树的平衡操作和更多的指针，跳表实现更加简单</p>
</li>
</ol>
<p>Redis选择跳跃表 是因为它完美平衡了动态操作、查找效率和实现复杂度，而二分查找和平衡树无法满足 ZSET 的需求</p></blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="6-redis持久化">
<a class="header-anchor" href="#6-redis%e6%8c%81%e4%b9%85%e5%8c%96"></a>
6. Redis持久化
</h3><h4 id="rdb快照">
<a class="header-anchor" href="#rdb%e5%bf%ab%e7%85%a7"></a>
RDB（快照）
</h4><p>RDB持久化方式会生成内存数据的一个快照里面并将其保存到二进制文件中。</p>
<p>工作原理：手动触发+自动触发</p>
<p>RDB手动触发方式有两种：</p>
<ol>
<li>
<p>sava</p>
<p>会阻塞redis服务器进程，直到rdb文件创建完成，在生产环境几乎不会使用。</p>
</li>
<li>
<p>bgsave</p>
<p>会fork出一个子进程，由子进程负责创建rdb文件，主进程继续处理客户端请求。</p>
</li>
</ol>
<p>除此之外还可以设置自动触发：例如：<code>save 900 1</code> 表示在 900 秒（15分钟）内，如果至少有 1 个键被修改，则触发 <code>BGSAVE</code>。</p>
<p>优点：</p>
<ul>
<li>性能高、恢复速度快</li>
<li>bgsave能够fork子进程，不影响主进程性能</li>
<li>适合大规模数据恢复</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据丢失风险高：由于是完整备份，每次耗时较长，不可能随时进行备份，最后一次快照之前所有修改的数据都将丢失</li>
<li>fork可能阻塞：虽然主进程不阻塞，但 <code>fork</code> 操作本身在数据量巨大时可能会消耗较多 CPU 和时间，导致服务器短暂停顿（毫秒级或秒级，取决于数据量和硬件）。</li>
</ul>
<h4 id="aof增量持久化">
<a class="header-anchor" href="#aof%e5%a2%9e%e9%87%8f%e6%8c%81%e4%b9%85%e5%8c%96"></a>
AOF（增量持久化）
</h4><p>AOF 持久化方式会<strong>记录每一次写操作命令</strong>，以日志的形式追加到一个文件的末尾。当 Redis 重启时，会<strong>重新执行</strong> AOF 文件中的所有命令来重建数据。</p>
<p>工作原理：</p>
<ol>
<li>命令追加：每当有写命令执行时，Redis 会以协议格式将该命令追加到服务器内部的 <code>aof_buf</code> 缓冲区中。</li>
<li>文件写入和同步：根据配置的<strong>appendfsync</strong>策略，将缓冲区中的内容写入和同步到 AOF 磁盘文件。
<ul>
<li><strong>appendfsync always</strong>：每个写命令都立即同步到磁盘。<strong>数据最安全，但性能最差</strong>。</li>
<li><strong>appendfsync everysec</strong>：每秒同步一次。<strong>默认推荐策略</strong>，在性能和数据安全之间取得了很好的平衡，最多丢失 1 秒钟的数据。</li>
<li><strong>appendfsync no</strong>：由操作系统决定何时同步。性能最好，但数据丢失风险最高。</li>
</ul>
</li>
<li>AOF重写：随着时间的推移，AOF文件会越来越大。Redis提供了bgrewriteaof命令（会fork子进程）来重写当前aof文件，从而创建一个新的、更小的aof文件，它包含重建当前数据集所需的最少命令集合。重写过程是安全的，新的 AOF 文件生成后，Redis 会切换使用它。</li>
</ol>
<p>优点：</p>
<ul>
<li>数据丢失风险更低：可以用每秒/每次来写缓冲并刷盘，最大限度减少数据丢失</li>
<li>可读性：AOF文件是纯文本格式，记录了所有操作命令，相较于RDB的二进制数据便于理解和分析</li>
</ul>
<p>缺点：</p>
<ul>
<li>文件体积大：AOF 文件通常比同数据集的 RDB 文件大。</li>
<li>恢复速度慢：恢复数据时需要逐条执行命令，比 RDB 慢。</li>
<li>对性能影响较高：虽然 <code>everysec</code> 策略性能不错，但通常仍比 RDB 略低。</li>
</ul>
<h4 id="混合持久化推荐持久化方式">
<a class="header-anchor" href="#%e6%b7%b7%e5%90%88%e6%8c%81%e4%b9%85%e5%8c%96%e6%8e%a8%e8%8d%90%e6%8c%81%e4%b9%85%e5%8c%96%e6%96%b9%e5%bc%8f"></a>
混合持久化（推荐持久化方式）
</h4><p>混合持久化（Hybrid Persistence）并不是一个独立的持久化方式，而是 <strong>在 AOF 重写机制基础上引入 RDB 数据格式</strong> 的一种优化。</p>
<p>内容组成：</p>
<ul>
<li><strong>RDB 数据快照</strong>：文件的开头部分，是某个时间点数据库内容的二进制 RDB 格式快照。</li>
<li><strong>AOF 增量命令</strong>：紧接在 RDB 数据之后，是快照点之后的所有写入操作的 AOF 格式命令。</li>
</ul>
<p>工作原理：混合持久化的触发时机和传统的 AOF 重写完全一样（手动执行 <code>BGREWRITEAOF</code> 或达到自动触发条件）</p>
<ul>
<li><strong>触发重写</strong>：当需要执行 AOF 重写时</li>
<li><strong>Fork 子进程</strong>：主进程调用 <code>fork()</code> 创建子进程。此时，子进程拥有与主进程完全一致的内存数据副本。</li>
<li><strong>生成 RDB 前导</strong>：<strong>这是最关键的一步</strong>。类似rdb持久化，子进程根据当前内存快照生成临时的aof文件（格式是rdb）</li>
<li><strong>缓冲增量命令</strong>：在子进程生成 RDB 部分的同时，主进程仍在正常处理客户端请求。所有新的写操作不仅会修改内存，还会继续写入<strong>旧的 AOF 文件</strong>和<strong>AOF 重写缓冲区</strong>。</li>
<li><strong>追加 AOF 尾部</strong>：当子进程完成 RDB 部分的写入后，它会通知主进程。主进程会将 <strong>AOF 重写缓冲区</strong> 中积累的所有增量命令（即步骤 3 之后发生的所有写操作）以 AOF 格式追加到临时文件中的 RDB 数据之后。</li>
<li><strong>原子替换</strong>：最后，Redis 会原子地用这个新的、包含 RDB 和 AOF 的混合文件替换掉旧的 AOF 文件。至此，重写完成。</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>快速恢复</strong>：重启 Redis 时，可以先加载 RDB 部分的内容，速度非常快。</li>
<li><strong>数据安全</strong>：再加载增量 AOF 命令，保证数据不丢失。</li>
</ul>
<h3 id="7-aof持久化导致主进程阻塞">
<a class="header-anchor" href="#7-aof%e6%8c%81%e4%b9%85%e5%8c%96%e5%af%bc%e8%87%b4%e4%b8%bb%e8%bf%9b%e7%a8%8b%e9%98%bb%e5%a1%9e"></a>
7. AOF持久化导致主进程阻塞
</h3><p>如果仅开启了AOF持久化（没开启RDB持久化），AOF重写操作会调用BGREWRITEAOF，具体步骤有点类似RDB，都会fork出一个子进程负责aof的重写工作。</p>
<img src="./images/image-20250906214136665.png" alt="image-20250906214136665" style="zoom: 50%;" />
<p>然而这可能会导致主进程阻塞：</p>
<p>当AOF子进程完成AOF重写工作后，它会向主进程发送一个信号。父进程在收到后会执行以下工作：</p>
<ul>
<li>将aof重写缓冲区的内容写入到新的AOF文件中，保证新的AOF文件和当前服务器数据一致</li>
<li>对新的AOF文件改名，原子覆盖现有AOF文件，完成新旧文件替换</li>
<li>继续处理客户端请求</li>
</ul>
<p>这三者都会涉及大量磁盘操作，造成资源竞争（机械磁盘通常是串行服务），</p>
<p>解决方法：</p>
<ul>
<li>
<p>使用SSD可以极大缓解这类问题</p>
</li>
<li>
<p>no-appendfsync-on-rewrite设置为yes：yes表示在日志AOF重写时，不进行aof文件命令追加操作，而只是将命令放在重写缓冲区里，避免与命</p>
<p>令的追加造成磁盘IO造成的阻塞。但是在rewrite期间的AOF有丢失的风险。</p>
</li>
<li>
<p><strong>开启混合持久化</strong></p>
<ul>
<li><strong>传统AOF重写</strong>：子进程需要遍历数据库，将每个键值对转换为相应的Redis命令（如<code>SET</code>, <code>HSET</code>, <code>SADD</code>等），然后将这些命令文本写入新AOF文件。这是一个<strong>CPU密集型</strong>操作，需要大量的序列化和文本生成。</li>
<li><strong>混合持久化重写</strong>：子进程直接调用RDB的序列化函数，将内存中的数据以紧凑的二进制格式写入文件。这个过程比生成AOF命令文本要<strong>快得多，CPU开销更小</strong>。</li>
</ul>
</li>
</ul>
<h3 id="8-redis集群高可用常见方式">
<a class="header-anchor" href="#8-redis%e9%9b%86%e7%be%a4%e9%ab%98%e5%8f%af%e7%94%a8%e5%b8%b8%e8%a7%81%e6%96%b9%e5%bc%8f"></a>
8. Redis集群高可用常见方式
</h3><h4 id="主从">
<a class="header-anchor" href="#%e4%b8%bb%e4%bb%8e"></a>
主从
</h4><h4 id="哨兵">
<a class="header-anchor" href="#%e5%93%a8%e5%85%b5"></a>
哨兵
</h4><h4 id="集群">
<a class="header-anchor" href="#%e9%9b%86%e7%be%a4"></a>
集群
</h4><h3 id="9-缓存一致性">
<a class="header-anchor" href="#9-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7"></a>
9. 缓存一致性
</h3><p>主要是数据库和缓存的数据一致性</p>
<h4 id="旁路缓存模式">
<a class="header-anchor" href="#%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f"></a>
旁路缓存模式
</h4><p>最为经典的缓存+数据库读写模式，主要有两个核心</p>
<ul>
<li>读取：先读取缓存，没有再读取缓存然后将数据放入缓存并返回客户端</li>
<li>写入：先修改数据库，然后删除缓存返回客户端</li>
</ul>
<h4 id="为什么一般情况选择删除缓存而不是更新缓存">
<a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%80%e8%88%ac%e6%83%85%e5%86%b5%e9%80%89%e6%8b%a9%e5%88%a0%e9%99%a4%e7%bc%93%e5%ad%98%e8%80%8c%e4%b8%8d%e6%98%af%e6%9b%b4%e6%96%b0%e7%bc%93%e5%ad%98"></a>
为什么一般情况选择删除缓存而不是更新缓存？
</h4><ul>
<li>写操作成本：缓存结果的计算可能成本较高，多个数据的修改都可能会触发缓存的更新，但是却不一定会被读取</li>
<li>读少写多的情况：频繁更新缓存是无用之举</li>
<li>懒加载思想：用的时候再取读取计算</li>
</ul>

  <blockquote class="alert-blockquote tip">
    <p class="alert-heading">
      Tip
    </p>
    <p><p>先更新数据库，再删除缓存。如果删除缓存失败了导致数据不一致怎么办？</p>
<p>答：先删除缓存，成功后再更新数据库，然后再尝试删一次，此时不管后续如何出问题，数据都是一致的</p></p>
  </blockquote>

<p>如何确保缓存的一致性？</p>
<h5 id="消息队列删除">
<a class="header-anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%88%a0%e9%99%a4"></a>
消息队列删除
</h5><p>使用消息队列确保删除缓存操作一定成功，然后这种方法对业务代码侵入性较大，不适合大规模应用。</p>
<h5 id="数据库订阅消息队列删除">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%a2%e9%98%85%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%88%a0%e9%99%a4"></a>
数据库订阅+消息队列删除
</h5><p>使用阿里云的canal的组件监听数据库的binlog日志，然后使用消息队列获取canal组件传递过来的消息，对自己需要删除的数据进行缓存删除操作。</p>
<p>适合大规模应用</p>
<h5 id="延时双删">
<a class="header-anchor" href="#%e5%bb%b6%e6%97%b6%e5%8f%8c%e5%88%a0"></a>
延时双删
</h5><p>具体过程为：先删除缓存-&gt;更新数据-&gt;延时一定时间-&gt;再删除缓存</p>
<p>然后对于延时的控制需要仔细考量和测试，通常延时1s能解决大部分业务需求。</p>
<h5 id="设置缓存过期时间兜底">
<a class="header-anchor" href="#%e8%ae%be%e7%bd%ae%e7%bc%93%e5%ad%98%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e5%85%9c%e5%ba%95"></a>
设置缓存过期时间兜底
</h5><p>这是一个较为简单的办法，意味着缓存不一致的情况最多持续ttl。但是对于高并发业务，仍然不算很好的解决方法，因为它仍然可能会一直不一致。</p>
<h3 id="10-缓存穿透缓存击穿和缓存雪崩">
<a class="header-anchor" href="#10-%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf%e5%92%8c%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9"></a>
10. 缓存穿透、缓存击穿和缓存雪崩
</h3><h4 id="缓存穿透">
<a class="header-anchor" href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f"></a>
缓存穿透
</h4><p>指查询缓存和数据库中都不存在的数据，这样请求每次都会查询数据库，然而数据库中不存在数据，也就不会将结果加入到缓存中，此时缓存完全不起作用，就好像没有缓存一样。</p>
<p>原因：</p>
<ol>
<li>
<p>恶意攻击</p>
<p>有人故意对不存在的数据进行查询</p>
</li>
<li>
<p>代码缺陷</p>
</li>
</ol>
<p>解决方法：</p>
<ol>
<li>对空值进行缓存</li>
<li>使用布隆过滤器，对于不存在的值直接返回，但是存在一定的误判率</li>
<li>对ip进行限流，防止恶意攻击</li>
</ol>
<h4 id="缓存击穿">
<a class="header-anchor" href="#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf"></a>
缓存击穿
</h4><p>缓存击穿讨论对象主要针对<strong>单个热key</strong>，当这个key存在过期时间，那么在过期的一瞬间将会有大量流量打进db层，如果并发量足够高可能会引发连锁效应进而导致数据库崩溃。</p>
<p>解决方法：</p>
<ol>
<li>热点数据永不过期</li>
<li>提前将热点数据加载到缓存（首次访问也可能导致缓存击穿，例如秒杀单个商品）</li>
<li>对访问db的过程加锁，防止多个请求穿过缓存请求db</li>
<li>每隔一段时间对热门数据过期时间进行延长</li>
</ol>
<h4 id="缓存雪崩">
<a class="header-anchor" href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9"></a>
缓存雪崩
</h4><p>缓存雪崩讨论场景是<strong>大规模缓存失效</strong>的情况，例如<strong>缓存宕机</strong>、<strong>大量热key同时到期</strong>，这样的后果就是大量请求打到db上，可能会引发连锁效应造成db崩溃或服务崩溃。</p>
<p>解决方案：</p>
<ul>
<li>提高缓存可用性：
<ul>
<li>集群部署：使用redis集群部署，提升系统可用性</li>
<li>多级缓存：使用本地缓存-分布式缓存的多级缓存结构，避免单一缓存崩溃影响系统</li>
</ul>
</li>
<li>分散热key过期时间
<ul>
<li>同时设置大量key的过期时间时添加随机时间，分散它们的时间点</li>
<li>永不过期（不建议）</li>
</ul>
</li>
<li>熔断降级</li>
</ul>
<h3 id="11-一致性hash算法todo">
<a class="header-anchor" href="#11-%e4%b8%80%e8%87%b4%e6%80%a7hash%e7%ae%97%e6%b3%95todo"></a>
11. 一致性hash算法（TODO）
</h3><h3 id="12-数据分片">
<a class="header-anchor" href="#12-%e6%95%b0%e6%8d%ae%e5%88%86%e7%89%87"></a>
12. 数据分片
</h3><p>数据分片指将所有数据分到若干个分区里面</p>
<h4 id="数据分片sharding基本类型">
<a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e5%88%86%e7%89%87sharding%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b"></a>
数据分片（Sharding）基本类型
</h4><ul>
<li>
<p>按时间范围：id范围、时间范围</p>
</li>
<li>
<p>id取模：也叫id取余</p>
</li>
<li>
<p>哈希取余：取余对象为哈希之后的计算结果</p>
<blockquote>
<p>存在问题：当增加或者减少结点时，由于之前数据的取余结果和新的取余结果可能不同，存在数据迁移问题。</p>
<p>当翻倍扩容时只需要迁移50%的数据，否则大批量数据都需要迁移</p></blockquote>
</li>
<li>
<p>一致性hash</p>
<blockquote>
<p>像是哈希+范围分配的结合，具体的来讲，是将所有数据通过hash函数映射到一个范围，例如[0,16383]<br>
假如我们有4个结点，那么就会将hash范围按照范围均匀分配给四个结点</p>
<p>第一个结点负责[0,4095],第二个结点负责[4096, 8191]&hellip;</p>
<p>当扩容时，不用均等分配，只需要将某个区间分裂即可。假设将第一个结点均等分裂成[0,2047]和[2048,4095]，那么此时大概只有12.5%的数据需要迁移到新的结点中去</p>
<p>**优点：**适合多节点伸缩扩容</p>
<p><strong>缺点</strong>：在数据规模小的场景下，可能会出现单位时间内某个节点完全空闲的情况</p></blockquote>
</li>
<li>
<p>哈希槽分片（redis集群）</p>
<blockquote>
<p>这里可以看看：<a href="https://study.disign.me/article/202509/4.redis-hash-key.md#2-3-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%8A%82%E7%82%B9%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5">面试官灵魂拷问：Redis 哈希槽与一致性哈希，你真能答对？ - 海量技术好文一站式集结 - 技术书栈</a></p>
<p>实际上按照自己的理解，是由于一致性hash在伸缩容易造成范围的不均匀导致可能的数据倾斜问题，因此在真实节点的基础上添加了虚拟节点，使得hash环的范围分配尽可能均匀。</p></blockquote>
</li>
</ul>
<h3 id="13-怎么处理热key">
<a class="header-anchor" href="#13-%e6%80%8e%e4%b9%88%e5%a4%84%e7%90%86%e7%83%adkey"></a>
13. 怎么处理热key
</h3><p>热key指的是短时间内被高频访问的数据，流量太过集中的极端情况下可能会造成redis服务的瘫痪</p>
<p>在处理之前我们要能够发现它：</p>
<ul>
<li>
<p>客户端监控</p>
<p>可以在客户端侧进行监控统计，或者根据业务进行提前预测</p>
</li>
<li>
<p>redis命令统计</p>
<p>monitor命令：可以实时打印出所有执行的命令，通过脚本分析输出结果来找出热 Key。<strong>（对性能影响巨大，仅用于临时调试）</strong></p>
</li>
<li>
<p>代理统计</p>
<p>很多公司使用 Twemproxy、Codis 或者自研的 Redis 代理层。可以在代理层上对请求进行统计，实时发现并上报访问频率异常的 Key。</p>
</li>
</ul>
<p>处理方法：</p>
<ul>
<li>
<p>建立本地缓存：使用caffine或者guava cache等本地缓存</p>
<p>具体流程：</p>
<ul>
<li>先检查本地是否存在缓存</li>
<li>如果本地缓存有则直接返回不再使用redis</li>
<li>如果本地缓存没有再去请求redis（redis也没有就查库），然后将数据写回本地缓存并设置较短的时间</li>
</ul>
</li>
<li>
<p>热key复制到多个redis节点</p>
</li>
</ul>
<h3 id="14-分布式锁todo">
<a class="header-anchor" href="#14-%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81todo"></a>
14. 分布式锁(TODO)
</h3><p>在微服务框架下，可能存在多个实例修改同一条数据，此时为了确保数据的一致性，需要限制只有一个实例可以对数据进行修改，通常方案有以下几种：</p>
<ul>
<li>基于数据库的悲观锁/乐观锁</li>
<li>基于redis实现分布式锁</li>
<li>基于zookeeper实现分布式锁</li>
<li>基于其他中间件实现分布式锁</li>
</ul>
<p>由于基于数据库的分布式锁通常性能较低，且和业务代码耦合比较严重，所以通常情况下分布式锁都不会采用数据库实现</p>
<p>这里主要讲讲基于redis的分布式锁</p>
<h4 id="基于redis的分布式锁">
<a class="header-anchor" href="#%e5%9f%ba%e4%ba%8eredis%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81"></a>
基于redis的分布式锁
</h4><p>可以看这个文章</p>
<p><a href="https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw">深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了！</a></p>
<h2 id="综合">
<a class="header-anchor" href="#%e7%bb%bc%e5%90%88"></a>
综合
</h2><h3 id="1-手写一个lrutodo">
<a class="header-anchor" href="#1-%e6%89%8b%e5%86%99%e4%b8%80%e4%b8%aalrutodo"></a>
1. 手写一个LRU（TODO）
</h3><ol>
<li>
<p>使用java的LinkedHashMap实现一个简单的LRU</p>
<p>相当于自带淘汰机制，不用我们写很多</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LRUCache</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxCapacity</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">LRUCache</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">maxCapacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 设置accessOrder为true，使得链表按访问顺序排序</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">super</span><span class="p">(</span><span class="n">maxCapacity</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">.</span><span class="na">75f</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">maxCapacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maxCapacity</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">removeEldestEntry</span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="w"> </span><span class="n">eldest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 当size超过最大容量时，移除最久未使用的元素</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">maxCapacity</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<h3 id="2-寻找大量key">
<a class="header-anchor" href="#2-%e5%af%bb%e6%89%be%e5%a4%a7%e9%87%8fkey"></a>
2. 寻找大量key
</h3><p>Redis里面有1亿个key，其中有10w个key是以某个 固定的已知的前缀开头的，如何将它们全部找出来？</p>
<p>在 Redis 中快速找出 1 亿个 key 中所有以特定前缀开头的 10 万个 key，需要避免阻塞生产环境，同时保证高效性。</p>
<ol>
<li>
<p>使用SCAN命令</p>
<p>SCAN 是游标式迭代器，分批次返回结果，避免 KEYS 的单次阻塞问题。例如<code>SCAN 0 MATCH &quot;prefix:*&quot; COUNT 1000</code>，实际效果类似分页，返回从第0个到第1000个数据中符合要求的数据。游标起始值只能是0（重新遍历）或者上一次scan返回的结果（上一次scan后游标停留的位置）</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>
<p>非阻塞：不会长时间阻塞主线程</p>
</li>
<li>
<p>可控：每次遍历数量可控</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>
<p>非原子性：多次SCAN之间数据可能存在变更，结果不保证完全一致</p>
</li>
<li>
<p>多次访问：并不能一次扫描所有结果</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用持久化文件进行离线分析</p>
</li>
</ol>
<h3 id="3-redis如何做异步消息队列-需要注意什么">
<a class="header-anchor" href="#3-redis%e5%a6%82%e4%bd%95%e5%81%9a%e5%bc%82%e6%ad%a5%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97-%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e4%bb%80%e4%b9%88"></a>
3. Redis如何做异步消息队列 需要注意什么？
</h3><p>可以使用lpush（生产）+brpop（阻塞式消费）实现一个简单的消息队列</p>
<p>如果需要实现一（消费者）对多（生产者），可以使用pub/sub的主题订阅模式，额可以实现一对多的消息队列。</p>
<p>需要注意的问题：</p>
<ul>
<li>
<p>消息丢失：</p>
<p><code>BRPOP</code> 弹出后消息就没了。如果消费者处理失败，消息无法恢复。</p>
<p>解决方案：使用peek先获取 或者 先放到另外一个队列中进行处理，处理完后再弹出或者删除</p>
</li>
<li>
<p>消息重复消费</p>
<p>网络问题、消费者重启等都可能导致消息被重复消费。</p>
<p>解决方案：保证业务逻辑的幂等性</p>
</li>
<li>
<p>消息堆积</p>
<p>队列过长会导致内存占用高</p>
<p>解决方案：增加消费者数量，建立良好的报警监控机制</p>
</li>
</ul>
<h3 id="4-rdb和copy-on-write">
<a class="header-anchor" href="#4-rdb%e5%92%8ccopy-on-write"></a>
4. RDB和Copy On Write
</h3><blockquote>
<p>Copy On Write(COW)是什么？</p>
<p>COW是操作系统提供的一种内存管理优化技术，其核心思想是：</p>
<p><strong>当父进程 fork 出子进程时，子进程不会立即复制父进程的内存，而是与父进程共享同一份物理内存页。只有当父进程或子进程尝试修改某块内存时，操作系统才会真正复制该内存页给子进程。</strong> 最大程度降低复制成本</p></blockquote>
<p>BGSAVE如何利用COW？</p>
<p>Redis的bgsave流程如下：</p>
<ul>
<li>fork子进程：子进程共享父进程的内存数据</li>
<li>COW机制生效：被修改的内存页会触发COW，从而降旧的内容拷贝给子进程</li>
<li>子进程生成rdb文件：子进程遍历所有键值对，生成rdb文件，cow决定了子进程读取的一定是bgsave时的历史快照</li>
<li>主进程替换旧的rdb文件：子进程写完rdb文件退出后，主进程会用新的rdb替换旧的rdb文件</li>
</ul>
<p>COW的优点：</p>
<ul>
<li>低延迟：子进程启动一瞬间不需要拷贝所有内存数据，只有修改才需要拷贝</li>
<li>高性能：主进程在 <code>BGSAVE</code> 期间仍可处理请求，只有<strong>被修改的内存页</strong>才会触发复制</li>
<li>数据一致性：COW 保证了子进程看到的数据是 fork 时的<strong>瞬时快照</strong>，不受后续写入干扰。</li>
</ul>
<p>但是在极端环境（所有数据都被修改）可能会导致内存占用较高，最高可达原始内存占用的两倍。</p>
<h3 id="5-redis阻塞问题怎么排查和解决">
<a class="header-anchor" href="#5-redis%e9%98%bb%e5%a1%9e%e9%97%ae%e9%a2%98%e6%80%8e%e4%b9%88%e6%8e%92%e6%9f%a5%e5%92%8c%e8%a7%a3%e5%86%b3"></a>
5. Redis阻塞问题怎么排查和解决
</h3><p>redis阻塞问题需要逐步排查，遵循从宏观到微观，从外部到内部一个个分析：</p>
<ol>
<li>是否网络延时问题？</li>
<li>是否redis实例问题？</li>
<li>是否只是个别命令阻塞？（例如大key等）</li>
</ol>
<p>通常redis阻塞原因有以下几点：</p>
<ol>
<li>
<p>网络问题</p>
<p>检查网络情况，例如带宽、丢包率等；redis实例和客户端网络通信问题</p>
</li>
<li>
<p>连接数过多</p>
<ul>
<li>使用连接池</li>
</ul>
</li>
<li>
<p>持久化fork阻塞</p>
<ul>
<li>减少 Redis 内存使用，<code>fork</code> 耗时与内存量正相关。</li>
<li>使用ssd硬盘</li>
</ul>
</li>
<li>
<p>aof刷盘阻塞</p>
<ul>
<li>将 <code>appendfsync</code> 从 <code>always</code> 改为 <code>everysec</code>（默认）</li>
</ul>
</li>
<li>
<p>内存交换</p>
<ul>
<li>增加物理内存</li>
</ul>
</li>
<li>
<p>慢查询问题</p>
<ul>
<li>发现：使用slowlog get(n) 获取最近的n条慢查询命令</li>
<li>优化操作：避免使用keys *等操作，优化算法防止一次操作过多对象或者大对象</li>
<li>拆分大命令：对大集合的 <code>HGETALL</code>、<code>SMEMBERS</code> 改为 <code>HSCAN</code>、<code>SSCAN</code></li>
</ul>
</li>
<li>
<p>大key操作：大key的读取、删除、添加都可能造成阻塞</p>
<ul>
<li>大key拆分：将一个大 Hash 拆分为多个小 Hash。</li>
<li>及时清理不用的数据，避免发展为大key。</li>
</ul>
</li>
<li>
<p>其他，例如缓存雪崩等、CPU饱和（主从or集群）</p>
</li>
</ol>
</div>
    <footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item" data-aos="zoom-in">
      <a
        class="article-tag-list-link"
        href="/tags/redis"
        rel="tag"
        >REDIS</a
      >
    </li></ul>
</footer>
  </div><nav
    id="article-nav"
    data-aos="fade-up"
  ><div class="article-nav-link-wrap article-nav-link-left"><img
              data-src="/cover/10.png"
              data-sizes="auto"
              alt="Mysql面试"
              class="lazyload"
            /><a href="/post/interview/mysql/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">Mysql面试</h3>
      </div><div class="article-nav-link-wrap article-nav-link-right"><img
              data-src="/cover/2.png"
              data-sizes="auto"
              alt="Mq"
              class="lazyload"
            /><a href="/post/interview/mq/"></a>
        <div class="article-nav-caption">后一篇</div>
        <h3 class="article-nav-title">Mq</h3>
      </div></nav></article></section>
        </div><footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info"><div>
      <span class="icon-copyright"></span>2020-2025<span class="footer-info-sep rotate"></span>
      tscxk
    </div><div>
        基于&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          >Hugo</a
        >&nbsp; Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          >Reimu</a
        >
      </div><div>
        <span class="icon-brush"
          >&nbsp;35.2k</span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;01:14</span>
      </div><div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >总访问量&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >总访客量&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div></div>
</footer>
<div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div><div id="mask" class="hide"></div>
      </div><nav id="mobile-nav">
  <div class="sidebar-wrap"><div class="sidebar-toc-sidebar"><h3 class="toc-title">文章目录</h3>
<div class="sidebar-toc-wrapper toc-div-class">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#redis基础">Redis基础</a>
      <ul>
        <li><a href="#1-使用缓存的优缺点">1. 使用缓存的优缺点</a></li>
        <li><a href="#2-redis的数据类型和使用场景">2. Redis的数据类型和使用场景</a></li>
        <li><a href="#3-redis的过期策略">3. Redis的过期策略</a></li>
        <li><a href="#4-redis的内存淘汰策略">4. Redis的内存淘汰策略</a></li>
        <li><a href="#4-redis的事务机制">4. Redis的事务机制</a></li>
        <li><a href="#5-redis为什么这么快">5. Redis为什么这么快？</a></li>
        <li><a href="#6-redis持久化">6. Redis持久化</a></li>
        <li><a href="#7-aof持久化导致主进程阻塞">7. AOF持久化导致主进程阻塞</a></li>
        <li><a href="#8-redis集群高可用常见方式">8. Redis集群高可用常见方式</a></li>
        <li><a href="#9-缓存一致性">9. 缓存一致性</a></li>
        <li><a href="#10-缓存穿透缓存击穿和缓存雪崩">10. 缓存穿透、缓存击穿和缓存雪崩</a></li>
        <li><a href="#11-一致性hash算法todo">11. 一致性hash算法（TODO）</a></li>
        <li><a href="#12-数据分片">12. 数据分片</a></li>
        <li><a href="#13-怎么处理热key">13. 怎么处理热key</a></li>
        <li><a href="#14-分布式锁todo">14. 分布式锁(TODO)</a></li>
      </ul>
    </li>
    <li><a href="#综合">综合</a>
      <ul>
        <li><a href="#1-手写一个lrutodo">1. 手写一个LRU（TODO）</a></li>
        <li><a href="#2-寻找大量key">2. 寻找大量key</a></li>
        <li><a href="#3-redis如何做异步消息队列-需要注意什么">3. Redis如何做异步消息队列 需要注意什么？</a></li>
        <li><a href="#4-rdb和copy-on-write">4. RDB和Copy On Write</a></li>
        <li><a href="#5-redis阻塞问题怎么排查和解决">5. Redis阻塞问题怎么排查和解决</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div></div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img
    data-src="/avatar/avatar.webp"
    data-sizes="auto"
    alt="tscxk"
    class="lazyload"
  />
  <div class="sidebar-author-name">tscxk</div>
  <div class="sidebar-description">叽里咕噜...</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div><div class="sidebar-state-number">8</div>
  </div>
  <a class="sidebar-state-category" href="/categories/" aria-label="sidebar-state-category-link">
    <div>分类</div>
    <div class="sidebar-state-number">
      3
    </div>
  </a>
  <a class="sidebar-state-tag" href="/tags/" aria-label="sidebar-state-tag-link">
    <div>标签</div>
    <div class="sidebar-state-number">9</div>
  </a>
</div>
<div class="sidebar-social"></div>
<div class="sidebar-menu"><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="首页"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">首页</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="归档"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">归档</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="关于"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">关于</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="友链"
      ></a>
      <div class='sidebar-menu-icon icon rotate'>&#xe62b;</div>
      <div class="sidebar-menu-link">友链</div>
    </div></div>
</div></div><div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div></nav>
</div><script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"></script><script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script><script src="/js/main.js" integrity="" crossorigin="anonymous" ></script><script src="/js/aos.js" integrity="" crossorigin="anonymous" ></script><script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script><script src="/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax></script><script
    src="https://npm.webcache.cn/mouse-firework@0.1.1/dist/index.umd.js"
    integrity="sha384-8LyaidD9GPxQQgLJO/WRw/O2h3BoNq/ApI/ecpvM6RsrCz2qP2ppBXUKihP4V/2d" crossorigin="anonymous"></script><script>
  if (window.firework) {
    const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"var(--red-1)\",\"var(--red-2)\",\"var(--red-3)\",\"var(--red-4)\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32]}},{\"colors\":[\"var(--red-0)\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"circle\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20}}]}");
    options.excludeElements = options.excludeelements;
    delete options.excludeelements;
    window.firework(options);
  }
</script>

<div id="lazy-script">
  <div><script data-pjax>
        window.REIMU_POST = {
          author: "tscxk",
          title: "Redis",
          url: "https:\/\/tscxk.github.io\/post\/interview\/redis\/",
          description: "Redis面试知识",
          cover: "https:\/\/tscxk.github.io\/images\/banner.webp",
        };
      </script><script src="/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax></script><script type="module" data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script></div>
</div><script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    asyncintegrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"></script><script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script><script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script></body>
</html>
