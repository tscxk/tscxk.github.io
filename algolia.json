[
  {
    "objectID": "2bdaebc0f2696e7828e9744c6530a20cd5cf77bf",
    "permalink": "/post/interview/mq/",
    "title": "Mq","content": "\r基础\r1. 为什么要使用MQ？有什么优缺点\r主要是因为MQ的优点，或者说是使用MQ的核心目的主要是：\n任务异步\n场景：部分比较耗时的操作，例如报表导出、发短信、日志存储等操作\nMQ作用：只需将任务添加到消息队列后即可返回给用户，后续耗时操作交给消息队列负责处理，提高了系统的即时响应速度\n业务解耦\n场景：上游系统调用若干下游系统，\n问题：上下游之间耦合严重（任意一个下游系统错误都会导致整个业务出错；每次添加一个下游系统时，上游系统都要修改代码）\nMQ作用：上游系统只需将消息丢给消息队列，下游系统只需要按需订阅自己需要的消息进行消费，降低了系统的耦合度\n流量削峰\n场景：上游系统突发流量，例如大量报表导出任务\n问题：下游系统很可能扛不住突发的大流量，需要对流量进行一定限制\nMQ作用：将任务请求放进消息队列中排序，下游系统按照自己消费能力消费消息，提高系统的可用性和稳定性\n除此之外，部分消息队列还提供以下特性：\n顺序性 持久化 最终一致性 MQ的缺点\r没有银弹，引入MQ也带来了一些复杂性和挑战：\n系统的复杂性提高 系统可用性降低：消息队列成为了最脆弱的地方，如果消息队列崩溃，那么相关业务也会出错 消息的丢失 消息的重复性消费 消息的持久化 消息的一致性 2. MQ有哪些常见问题？怎么解决？\r消息的顺序问题\n在Rocketmq里面，Message Queue是典型的FIFO，天然顺序。因此我们只需要确保顺序生产顺序消费即可。\n具体来讲就是使用一个线程生产消息，使用一个queue存储消息，使用一个线程消费消息，这样就严格保证了消息的顺序消费。\nImportant\r这种方案很明显严重限制了应用的吞吐量。\n也因此，我们更应该结合业务的角度去确保消息的顺序性，而不是单单依靠消息系统来确保。\n例如将一个用户的消息（下单、发货、收获、结算）都发送到一个消息队列中，同时确保这些消息只会被一个消费者消费即可，那么就是总体无序（还有很多其他的用户消息），业务有序。\n消息重复消息\n由于网络问题导致重复投递；或者消费者消费后宕机，重启后再次受到消息等多种原因，消费者可能会面临消息重复消费的问题，\n解决思想：保证业务的幂等性\n解决方案：\n基于数据库\n对于新增数据：使用数据库唯一索引确保消息的幂等性。在封装到消息队列中时添加全局唯一id，并在新增到数据库时将这个id保存起来作为唯一键，后续如果重复消 …","date": "2025-09-08 09:07:51",
    "updated": "2025-09-09 20:14:33"
  }, 
  {
    "objectID": "39037e793a899504f7b78bdaef47de6cc6a0a831",
    "permalink": "/post/interview/redis/",
    "title": "Redis","content": "\rRedis基础\rRedis是用C语言开发的\n1. 使用缓存的优缺点\r优点\r高性能（最根本的问题）\n对于能够容忍短时间内不一致的数据，使用缓存能够大大加快查询时间并降低数据库压力。因为缓存通常基于内存，性能相较于使用磁盘的数据库要强上许多数量级。\n高并发\n缓存基于内存，它所能提供的qps要大大高于数据库\n缺点\r缓存和数据库的不一致性 缓存穿透、击穿、雪崩问题 2. Redis的数据类型和使用场景\rString\r最基础的数据类型，可以存储任何数据，包括文字、数字、二进制数据、序列化后的java对象\n常用命令：get、set、incr、decr\n使用场景：\n简单对象缓存：如用户信息等，序列化成JSON后存入\n计数器：例如限流、\n分布式锁：使用SET key value NX EX seconds 实现简单的分布式锁\nHash\r类似于Java中的Map，适合存储对象\n常用命令：hset、hget、hgetall、hmset、hincrby 使用场景： 存储完整对象信息，需要频繁进行若干字段的变更：例如购物车 List\r简单的字符串列表，按照插入顺序排序，底层实现是双向链表\n常用命令：lpush、rpush、lpop、rpop、lrange 使用场景： 消息队列：基于redis实现简单的消息队列 最新列表：某个用户最近的朋友圈、最近的操作记录等不需要去重的场景 Set\r无序的、元素唯一的字符串集合。支持交集、并集、差集等操作\n常用命令：sadd、smembers、sismember、sinter、sunion、sdiff 使用场景： 求交集：共同好友、兴趣爱好 求差集：推荐好友 去重场景：抽奖用户添加 ZSet\r最特色的数据类型，相较于set，每个元素都关联一个权重（分数），Redis可以根据这个权重对所有数据进行排序\n常用命令：zadd、zrange、zrevrange、zrank、zrevrank 使用场景： 带有权重的排行榜：例如积分排行榜、充值排行榜 延迟队列：使用时间戳作为权重，消费者使用ZRANGEBYSCORE 查询到期的任务来处理 范围查询：例如处理价格范围、时间范围的数据 Bitmap\r使用场景：具备状态的二值统计，例如用户签到记录、活跃用户统计 Hyperloglog\r使用场景：统计网站的UB，统计搜索关键字的不重复数量 Bloom\rRedis 布隆过滤 …","date": "2025-09-05 09:59:02",
    "updated": "2025-09-08 15:10:28"
  }, 
  {
    "objectID": "17c5a35e0427afd9781c084f553ca3f0c524d48a",
    "permalink": "/post/interview/mysql/",
    "title": "Mysql面试","content": "\rMysql基础\r1. MySQL数据库中MyISAM和InnoDB的区别\rMyISAM:\n不支持事务，但每次查询都是原子的 不支持行级锁 不支持外键约束 使用非聚簇索引 存储表的总行数 InnoDB:\n支持事务并且有四种隔离级别 支持行级锁 拥有redo log，支持崩溃后数据恢复 用户undo log，支持事务回滚 使用聚簇索引 不存储表的总行数 2. 数据库的三范式\r每个字段具有原子性，即每列数据不可再拆分 非主键字段完全依赖主键 非主键字段直接依赖主键字段，不存在间接依赖 3. B树和B+树 为什么Mysql选择B+树\rB树和B+树都是多路平衡搜索树，B+树是B树的变种，在数据库索引领域几乎取代了B树\nB树结构特点：\n所有节点存储数据 叶子结点和非叶子节点结构相同，非叶子节点的键不会在叶子节点中再次出现 节点内部存储数据有序：节点内部数据可以用二分法查找 B+树结构特点：\n数据只存储在叶子节点，非叶子节点只存储指针 叶子节点形成有序链表 非叶子节点的键会在叶子结点再次出现 为什么选择B+树\n更低的树高，更少的IO\n由于非叶子节点不存储数据，这意味着每个非叶子节点可以存储更多的键，在相同的数据规模的情况下，B+树会更矮，这会消耗更少的IO次数\n支持范围查询\n由于B+数的叶子节点有序，这意味着它可以更好的支持范围查询，相较之下，B树则需要复杂的中序遍历\n更稳定的查询效率\n这是B+树相对于B树最大的优势。叶子节点的链表结构使得范围查询几乎是线性的，性能极佳。而B树需要进行复杂的中序遍历。\n更好的空间局部性\n叶子节点存储所有数据，并且是顺序的，更适合磁盘的预读特性。全表扫描只需要遍历叶子节点链表即可，效率非常高。\n4. 一条sql的执行过程\r连接器\n作用：管理客户端连接、身份认证和权限校验\n查询缓存\n作用：缓存select查询结果，如果命中则直接缓存，否则继续执行并将结果存入缓存\n但是在Mysql8.0之后，查询缓存已被移除\n原因：任何对表的更改操作（INSERT/UPDATE/DELETE）都会使该表的所有查询缓存失效。对于更新频繁的系统，缓存命中率极低，维护缓存反而带来巨大开销。\n分析器\n作用：进行词法分析+语法分析\n词法分析：对sql语句进行拆分识别，例如识别出字段、表、查询条件等 语法分析：根据mysql的语法规则判断SQL语法的正确性 优化器\n作用：它会选 …","date": "2025-08-26 20:22:56",
    "updated": "2025-09-08 15:10:17"
  }, 
  {
    "objectID": "502a5a5e4979112e1e864b1183ff6fc8dff3a14b",
    "permalink": "/post/interview/jvm/",
    "title": "Jvm面试","content": "\r综合\r1. 说说JVM的主要组成部分和流程\rJVM主要包含两个子系统和两个组件，两个子系统分别是Class loader(类装载)、Execution engine(执行引擎)；两个组件分别是Runtime data area(运行时数据区)、Native Interface(本地接口)。\nClass loader(类装载)：根据类的全限定名来装载class到运行时数据区域的方法区中 Runtime data area(运行时数据区)：即我们常说的JVM的内存 Execution engine(执行引擎)：负责将字节码文件“翻译”成对应平台上的机器指令并执行 Native Interface(本地接口)：和其它编程语言交互的接口 流程：编译器首先将Java代码转换成字节码。类加载器负责将字节码加载到运行时数据区域的方法区中。由于字节码是跨平台语言，因此需要解释器引擎根据平台翻译成具体的机器指令再交由cpu执行。本地库接口则是方面java代码进行系统调用或者其他函数的调用。\n2. 讲讲JVM内存模型\r程序计数器（线程私有）：\n存放当前线程的下一条指令地址。通过改变它来实现程序的流转控制，如循环、跳转、线程恢复等\n虚拟机栈（线程私有）：\n主要存放栈帧；每个方法被执行时，都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法从调用到执行完成，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n本地方法栈（线程私有）：\n和虚拟机栈功能类似。不同的是它是为Native方法服务的。\n堆（共享）：\n几乎所有的对象实例和数组都在这里分配内存，这里是GC的主要区域，也被称为GC堆\n方法区（共享）：\n存储内容包括已被加载的类的元数据信息（如类名、方法信息、字段信息）、类静态变量、运行时常量池和即时编译器编译后的代码缓存等\nImportant\r部分名词概念：\n局部变量表：包括基本数据类型和对象引用，其中基本数据类型是没有实例的概念的，这部分数据都在这里面\n操作数栈：存储计算过程的中间结果和临时操作数\n动态链接：栈帧内部的一个指针，指向运行时常量池（Runtime Constant Pool） 中该栈帧所属方法的引用。主要作用是将符号引用转为直接引用。其中**“动态”**的含义在于有些方法的直接引用需要到运行时才能确定。\n方法出口：存放着调用该方法的指令的下一条指 …","date": "2025-08-22 10:08:31",
    "updated": "2025-09-08 15:10:56"
  }, 
  {
    "objectID": "44c057bc80b2bbf34b6b410a9e99ebc0e55c3e61",
    "permalink": "/post/mysql/index_fail/",
    "title": "索引失效场景","content": "\r前言\r把啦啦啦\n一、测试表设计\rCREATE TABLE `user` ( `id` INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, `user_id` VARCHAR(20) NOT NULL COMMENT \u0026#39;用户ID（字符串类型）\u0026#39;, `username` VARCHAR(50) NOT NULL COMMENT \u0026#39;用户名\u0026#39;, `age` TINYINT NOT NULL COMMENT \u0026#39;年龄\u0026#39;, `city` VARCHAR(20) NOT NULL COMMENT \u0026#39;城市\u0026#39;, `salary` INT NOT NULL COMMENT \u0026#39;薪资\u0026#39;, `phone` CHAR(11) COMMENT \u0026#39;手机号\u0026#39;, `status` TINYINT NOT NULL DEFAULT 0 COMMENT \u0026#39;状态\u0026#39;, `score` INT NOT NULL DEFAULT 0 COMMENT \u0026#39;分数\u0026#39;, `create_time` DATETIME NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 索引配置 UNIQUE KEY `uniq_user_id` (`user_id`), KEY `idx_username_age_city` (`username`,`age`,`city`), KEY `idx_create_time` (`create_time`), KEY `idx_score` (`score`), KEY `idx_phone` (`phone`), KEY `idx_status` (`status`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 二、失效场景\r场景1： 索引列参与计算\r-- ❌ 错误写法：对索引列使用函数 SELECT * FROM user WHERE YEAR(create_time) = 2025; -- ✅ 优化方案：保持索引列原始值 SELECT * FROM user WHERE create_time BETWEEN \u0026#39;2025-01-01\u0026#39; AND \u0026#39;2025-12-31\u0026#39;; ","date": "2025-08-21 20:25:47",
    "updated": "2025-09-08 15:12:42"
  }, 
  {
    "objectID": "ceb80812863e8da5a15c9726e238ed12e52de6da",
    "permalink": "/post/study/java/spring/source_code/test/",
    "title": "Test","content": "This is a Chinese test post.\n善我王上魚、產生資西員合兒臉趣論。畫衣生這著爸毛親可時，安程幾？合學作。觀經而作建。都非子作這！法如言子你關！手師也。\n以也座論頭室業放。要車時地變此親不老高小是統習直麼調未，行年香一？\n就竟在，是我童示讓利分和異種百路關母信過明驗有個歷洋中前合著區亮風值新底車有正結，進快保的行戰從：弟除文辦條國備當來際年每小腳識世可的的外的廣下歌洲保輪市果底天影；全氣具些回童但倒影發狀在示，數上學大法很，如要我……月品大供這起服滿老？應學傳者國：山式排只不之然清同關；細車是！停屋常間又，資畫領生，相們制在？公別的人寫教資夠。資再我我！只臉夫藝量不路政吃息緊回力之；兒足灣電空時局我怎初安。意今一子區首者微陸現際安除發連由子由而走學體區園我車當會，經時取頭，嚴了新科同？很夫營動通打，出和導一樂，查旅他。坐是收外子發物北看蘭戰坐車身做可來。道就學務。\n國新故。\n工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？\nFrom 亂數假文產生器 - Chinese Lorem Ipsum\n","date": "2025-08-21 10:12:19",
    "updated": "2025-09-08 15:29:33"
  }, 
  {
    "objectID": "504adca92ad95fbf4c471bdb6cbcb300a8685a40",
    "permalink": "/post/main/",
    "title": "Markdown Basic Elements","content": "\rMarkdown 基本元素\r标题\rH1\rH2\rH3\rH4\rH5\rH6\r强调\rEmphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\n列表\rDefinition List (dl)\rDefinition List TitleThis is a definition list division.\rOrdered List (ol)\rList Item 1 List Item 2 List Item 3 Unordered List (ul)\rList Item 1 List Item 2 List Item 3 段落\rLorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper …","date": "2022-06-09 20:12:52",
    "updated": "2025-09-08 15:10:42"
  }, 
  {
    "objectID": "daeb6251321373d6006136db1dfff66c0d518fbd",
    "permalink": "/post/first/",
    "title": "模板创建来源","content": "This is a Chinese test post.\n文章模板转载来源：\nGithub\rhttps://github.com/D-Sketon/hugo-theme-reimu\r部署参考：\n部署参考\rhttps://linux.do/t/topic/878595\r","date": "2022-06-09 20:12:52",
    "updated": "2025-09-08 15:12:34"
  }]